{"ast":null,"code":"\"use strict\";\n\nvar baseEncodeTables = {\n  26: \"abcdefghijklmnopqrstuvwxyz\",\n  32: \"123456789abcdefghjkmnpqrstuvwxyz\",\n  // no 0lio\n  36: \"0123456789abcdefghijklmnopqrstuvwxyz\",\n  49: \"abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\",\n  // no lIO\n  52: \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n  58: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\",\n  // no 0lIO\n  62: \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n  64: \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_\"\n};\n\n/**\n * @param {Uint32Array} uint32Array Treated as a long base-0x100000000 number, little endian\n * @param {number} divisor The divisor\n * @return {number} Modulo (remainder) of the division\n */\nfunction divmod32(uint32Array, divisor) {\n  var carry = 0;\n  for (var i = uint32Array.length - 1; i >= 0; i--) {\n    var value = carry * 0x100000000 + uint32Array[i];\n    carry = value % divisor;\n    uint32Array[i] = Math.floor(value / divisor);\n  }\n  return carry;\n}\nfunction encodeBufferToBase(buffer, base, length) {\n  var encodeTable = baseEncodeTables[base];\n  if (!encodeTable) {\n    throw new Error(\"Unknown encoding base\" + base);\n  }\n\n  // Input bits are only enough to generate this many characters\n  var limit = Math.ceil(buffer.length * 8 / Math.log2(base));\n  length = Math.min(length, limit);\n\n  // Most of the crypto digests (if not all) has length a multiple of 4 bytes.\n  // Fewer numbers in the array means faster math.\n  var uint32Array = new Uint32Array(Math.ceil(buffer.length / 4));\n\n  // Make sure the input buffer data is copied and is not mutated by reference.\n  // divmod32() would corrupt the BulkUpdateDecorator cache otherwise.\n  buffer.copy(Buffer.from(uint32Array.buffer));\n  var output = \"\";\n  for (var i = 0; i < length; i++) {\n    output = encodeTable[divmod32(uint32Array, base)] + output;\n  }\n  return output;\n}\nvar crypto = undefined;\nvar createXXHash64 = undefined;\nvar createMd4 = undefined;\nvar BatchedHash = undefined;\nvar BulkUpdateDecorator = undefined;\nfunction getHashDigest(buffer, algorithm, digestType, maxLength) {\n  algorithm = algorithm || \"xxhash64\";\n  maxLength = maxLength || 9999;\n  var hash;\n  if (algorithm === \"xxhash64\") {\n    if (createXXHash64 === undefined) {\n      createXXHash64 = require(\"./hash/xxhash64\");\n      if (BatchedHash === undefined) {\n        BatchedHash = require(\"./hash/BatchedHash\");\n      }\n    }\n    hash = new BatchedHash(createXXHash64());\n  } else if (algorithm === \"md4\") {\n    if (createMd4 === undefined) {\n      createMd4 = require(\"./hash/md4\");\n      if (BatchedHash === undefined) {\n        BatchedHash = require(\"./hash/BatchedHash\");\n      }\n    }\n    hash = new BatchedHash(createMd4());\n  } else if (algorithm === \"native-md4\") {\n    if (typeof crypto === \"undefined\") {\n      crypto = require(\"crypto\");\n      if (BulkUpdateDecorator === undefined) {\n        BulkUpdateDecorator = require(\"./hash/BulkUpdateDecorator\");\n      }\n    }\n    hash = new BulkUpdateDecorator(function () {\n      return crypto.createHash(\"md4\");\n    }, \"md4\");\n  } else {\n    if (typeof crypto === \"undefined\") {\n      crypto = require(\"crypto\");\n      if (BulkUpdateDecorator === undefined) {\n        BulkUpdateDecorator = require(\"./hash/BulkUpdateDecorator\");\n      }\n    }\n    hash = new BulkUpdateDecorator(function () {\n      return crypto.createHash(algorithm);\n    }, algorithm);\n  }\n  hash.update(buffer);\n  if (digestType === \"base26\" || digestType === \"base32\" || digestType === \"base36\" || digestType === \"base49\" || digestType === \"base52\" || digestType === \"base58\" || digestType === \"base62\") {\n    return encodeBufferToBase(hash.digest(), digestType.substr(4), maxLength);\n  } else {\n    return hash.digest(digestType || \"hex\").substr(0, maxLength);\n  }\n}\nmodule.exports = getHashDigest;","map":{"version":3,"names":["baseEncodeTables","divmod32","uint32Array","divisor","carry","i","length","value","Math","floor","encodeBufferToBase","buffer","base","encodeTable","Error","limit","ceil","log2","min","Uint32Array","copy","Buffer","from","output","crypto","undefined","createXXHash64","createMd4","BatchedHash","BulkUpdateDecorator","getHashDigest","algorithm","digestType","maxLength","hash","require","createHash","update","digest","substr","module","exports"],"sources":["D:/Newton school/Java worked programs/React/PokemkonAPI/node_modules/loader-utils/lib/getHashDigest.js"],"sourcesContent":["\"use strict\";\n\nconst baseEncodeTables = {\n  26: \"abcdefghijklmnopqrstuvwxyz\",\n  32: \"123456789abcdefghjkmnpqrstuvwxyz\", // no 0lio\n  36: \"0123456789abcdefghijklmnopqrstuvwxyz\",\n  49: \"abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\", // no lIO\n  52: \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n  58: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\", // no 0lIO\n  62: \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n  64: \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_\",\n};\n\n/**\n * @param {Uint32Array} uint32Array Treated as a long base-0x100000000 number, little endian\n * @param {number} divisor The divisor\n * @return {number} Modulo (remainder) of the division\n */\nfunction divmod32(uint32Array, divisor) {\n  let carry = 0;\n  for (let i = uint32Array.length - 1; i >= 0; i--) {\n    const value = carry * 0x100000000 + uint32Array[i];\n    carry = value % divisor;\n    uint32Array[i] = Math.floor(value / divisor);\n  }\n  return carry;\n}\n\nfunction encodeBufferToBase(buffer, base, length) {\n  const encodeTable = baseEncodeTables[base];\n\n  if (!encodeTable) {\n    throw new Error(\"Unknown encoding base\" + base);\n  }\n\n  // Input bits are only enough to generate this many characters\n  const limit = Math.ceil((buffer.length * 8) / Math.log2(base));\n  length = Math.min(length, limit);\n\n  // Most of the crypto digests (if not all) has length a multiple of 4 bytes.\n  // Fewer numbers in the array means faster math.\n  const uint32Array = new Uint32Array(Math.ceil(buffer.length / 4));\n\n  // Make sure the input buffer data is copied and is not mutated by reference.\n  // divmod32() would corrupt the BulkUpdateDecorator cache otherwise.\n  buffer.copy(Buffer.from(uint32Array.buffer));\n\n  let output = \"\";\n\n  for (let i = 0; i < length; i++) {\n    output = encodeTable[divmod32(uint32Array, base)] + output;\n  }\n\n  return output;\n}\n\nlet crypto = undefined;\nlet createXXHash64 = undefined;\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\nlet BulkUpdateDecorator = undefined;\n\nfunction getHashDigest(buffer, algorithm, digestType, maxLength) {\n  algorithm = algorithm || \"xxhash64\";\n  maxLength = maxLength || 9999;\n\n  let hash;\n\n  if (algorithm === \"xxhash64\") {\n    if (createXXHash64 === undefined) {\n      createXXHash64 = require(\"./hash/xxhash64\");\n\n      if (BatchedHash === undefined) {\n        BatchedHash = require(\"./hash/BatchedHash\");\n      }\n    }\n\n    hash = new BatchedHash(createXXHash64());\n  } else if (algorithm === \"md4\") {\n    if (createMd4 === undefined) {\n      createMd4 = require(\"./hash/md4\");\n\n      if (BatchedHash === undefined) {\n        BatchedHash = require(\"./hash/BatchedHash\");\n      }\n    }\n\n    hash = new BatchedHash(createMd4());\n  } else if (algorithm === \"native-md4\") {\n    if (typeof crypto === \"undefined\") {\n      crypto = require(\"crypto\");\n\n      if (BulkUpdateDecorator === undefined) {\n        BulkUpdateDecorator = require(\"./hash/BulkUpdateDecorator\");\n      }\n    }\n\n    hash = new BulkUpdateDecorator(() => crypto.createHash(\"md4\"), \"md4\");\n  } else {\n    if (typeof crypto === \"undefined\") {\n      crypto = require(\"crypto\");\n\n      if (BulkUpdateDecorator === undefined) {\n        BulkUpdateDecorator = require(\"./hash/BulkUpdateDecorator\");\n      }\n    }\n\n    hash = new BulkUpdateDecorator(\n      () => crypto.createHash(algorithm),\n      algorithm\n    );\n  }\n\n  hash.update(buffer);\n\n  if (\n    digestType === \"base26\" ||\n    digestType === \"base32\" ||\n    digestType === \"base36\" ||\n    digestType === \"base49\" ||\n    digestType === \"base52\" ||\n    digestType === \"base58\" ||\n    digestType === \"base62\"\n  ) {\n    return encodeBufferToBase(hash.digest(), digestType.substr(4), maxLength);\n  } else {\n    return hash.digest(digestType || \"hex\").substr(0, maxLength);\n  }\n}\n\nmodule.exports = getHashDigest;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}