{"ast":null,"code":"\"use strict\";\n\nvar path = require(\"path\");\nvar getHashDigest = require(\"./getHashDigest\");\nfunction interpolateName(loaderContext, name) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var filename;\n  var hasQuery = loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;\n  if (typeof name === \"function\") {\n    filename = name(loaderContext.resourcePath, hasQuery ? loaderContext.resourceQuery : undefined);\n  } else {\n    filename = name || \"[hash].[ext]\";\n  }\n  var context = options.context;\n  var content = options.content;\n  var regExp = options.regExp;\n  var ext = \"bin\";\n  var basename = \"file\";\n  var directory = \"\";\n  var folder = \"\";\n  var query = \"\";\n  if (loaderContext.resourcePath) {\n    var parsed = path.parse(loaderContext.resourcePath);\n    var resourcePath = loaderContext.resourcePath;\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path.sep;\n    }\n    if (typeof context !== \"undefined\") {\n      directory = path.relative(context, resourcePath + \"_\").replace(/\\\\/g, \"/\").replace(/\\.\\.(\\/)?/g, \"_$1\");\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, \"/\").replace(/\\.\\.(\\/)?/g, \"_$1\");\n    }\n    if (directory.length === 1) {\n      directory = \"\";\n    } else if (directory.length > 1) {\n      folder = path.basename(directory);\n    }\n  }\n  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {\n    query = loaderContext.resourceQuery;\n    var hashIdx = query.indexOf(\"#\");\n    if (hashIdx >= 0) {\n      query = query.substr(0, hashIdx);\n    }\n  }\n  var url = filename;\n  if (content) {\n    // Match hash template\n    url = url\n    // `hash` and `contenthash` are same in `loader-utils` context\n    // let's keep `hash` for backward compatibility\n    .replace(/\\[(?:([^[:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi, function (all, hashType, digestType, maxLength) {\n      return getHashDigest(content, hashType, digestType, parseInt(maxLength, 10));\n    });\n  }\n  url = url.replace(/\\[ext\\]/gi, function () {\n    return ext;\n  }).replace(/\\[name\\]/gi, function () {\n    return basename;\n  }).replace(/\\[path\\]/gi, function () {\n    return directory;\n  }).replace(/\\[folder\\]/gi, function () {\n    return folder;\n  }).replace(/\\[query\\]/gi, function () {\n    return query;\n  });\n  if (regExp && loaderContext.resourcePath) {\n    var match = loaderContext.resourcePath.match(new RegExp(regExp));\n    match && match.forEach(function (matched, i) {\n      url = url.replace(new RegExp(\"\\\\[\" + i + \"\\\\]\", \"ig\"), matched);\n    });\n  }\n  if (typeof loaderContext.options === \"object\" && typeof loaderContext.options.customInterpolateName === \"function\") {\n    url = loaderContext.options.customInterpolateName.call(loaderContext, url, name, options);\n  }\n  return url;\n}\nmodule.exports = interpolateName;","map":{"version":3,"names":["path","require","getHashDigest","interpolateName","loaderContext","name","options","arguments","length","undefined","filename","hasQuery","resourceQuery","resourcePath","context","content","regExp","ext","basename","directory","folder","query","parsed","parse","substr","dir","sep","relative","replace","hashIdx","indexOf","url","all","hashType","digestType","maxLength","parseInt","match","RegExp","forEach","matched","i","customInterpolateName","call","module","exports"],"sources":["D:/Newton school/Java worked programs/React/PokemkonAPI/node_modules/loader-utils/lib/interpolateName.js"],"sourcesContent":["\"use strict\";\n\nconst path = require(\"path\");\nconst getHashDigest = require(\"./getHashDigest\");\n\nfunction interpolateName(loaderContext, name, options = {}) {\n  let filename;\n\n  const hasQuery =\n    loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;\n\n  if (typeof name === \"function\") {\n    filename = name(\n      loaderContext.resourcePath,\n      hasQuery ? loaderContext.resourceQuery : undefined\n    );\n  } else {\n    filename = name || \"[hash].[ext]\";\n  }\n\n  const context = options.context;\n  const content = options.content;\n  const regExp = options.regExp;\n\n  let ext = \"bin\";\n  let basename = \"file\";\n  let directory = \"\";\n  let folder = \"\";\n  let query = \"\";\n\n  if (loaderContext.resourcePath) {\n    const parsed = path.parse(loaderContext.resourcePath);\n    let resourcePath = loaderContext.resourcePath;\n\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path.sep;\n    }\n\n    if (typeof context !== \"undefined\") {\n      directory = path\n        .relative(context, resourcePath + \"_\")\n        .replace(/\\\\/g, \"/\")\n        .replace(/\\.\\.(\\/)?/g, \"_$1\");\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, \"/\").replace(/\\.\\.(\\/)?/g, \"_$1\");\n    }\n\n    if (directory.length === 1) {\n      directory = \"\";\n    } else if (directory.length > 1) {\n      folder = path.basename(directory);\n    }\n  }\n\n  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {\n    query = loaderContext.resourceQuery;\n\n    const hashIdx = query.indexOf(\"#\");\n\n    if (hashIdx >= 0) {\n      query = query.substr(0, hashIdx);\n    }\n  }\n\n  let url = filename;\n\n  if (content) {\n    // Match hash template\n    url = url\n      // `hash` and `contenthash` are same in `loader-utils` context\n      // let's keep `hash` for backward compatibility\n      .replace(\n        /\\[(?:([^[:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi,\n        (all, hashType, digestType, maxLength) =>\n          getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))\n      );\n  }\n\n  url = url\n    .replace(/\\[ext\\]/gi, () => ext)\n    .replace(/\\[name\\]/gi, () => basename)\n    .replace(/\\[path\\]/gi, () => directory)\n    .replace(/\\[folder\\]/gi, () => folder)\n    .replace(/\\[query\\]/gi, () => query);\n\n  if (regExp && loaderContext.resourcePath) {\n    const match = loaderContext.resourcePath.match(new RegExp(regExp));\n\n    match &&\n      match.forEach((matched, i) => {\n        url = url.replace(new RegExp(\"\\\\[\" + i + \"\\\\]\", \"ig\"), matched);\n      });\n  }\n\n  if (\n    typeof loaderContext.options === \"object\" &&\n    typeof loaderContext.options.customInterpolateName === \"function\"\n  ) {\n    url = loaderContext.options.customInterpolateName.call(\n      loaderContext,\n      url,\n      name,\n      options\n    );\n  }\n\n  return url;\n}\n\nmodule.exports = interpolateName;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}